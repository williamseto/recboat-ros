// Generated by gencpp from file span_pose/span_pose.msg
// DO NOT EDIT!


#ifndef SPAN_POSE_MESSAGE_SPAN_POSE_H
#define SPAN_POSE_MESSAGE_SPAN_POSE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace span_pose
{
template <class ContainerAllocator>
struct span_pose_
{
  typedef span_pose_<ContainerAllocator> Type;

  span_pose_()
    : header()
    , ver(0)
    , sec(0)
    , usec(0)
    , lat(0.0)
    , lon(0.0)
    , north(0.0)
    , east(0.0)
    , z(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , vel(0.0)
    , nsat(0)
    , ins_stat(0)
    , sol(0)
    , pos(0)
    , ins_str()
    , sol_str()
    , pos_str()  {
    }
  span_pose_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , ver(0)
    , sec(0)
    , usec(0)
    , lat(0.0)
    , lon(0.0)
    , north(0.0)
    , east(0.0)
    , z(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , vel(0.0)
    , nsat(0)
    , ins_stat(0)
    , sol(0)
    , pos(0)
    , ins_str(_alloc)
    , sol_str(_alloc)
    , pos_str(_alloc)  {
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _ver_type;
  _ver_type ver;

   typedef uint32_t _sec_type;
  _sec_type sec;

   typedef uint32_t _usec_type;
  _usec_type usec;

   typedef double _lat_type;
  _lat_type lat;

   typedef double _lon_type;
  _lon_type lon;

   typedef double _north_type;
  _north_type north;

   typedef double _east_type;
  _east_type east;

   typedef double _z_type;
  _z_type z;

   typedef float _roll_type;
  _roll_type roll;

   typedef float _pitch_type;
  _pitch_type pitch;

   typedef float _yaw_type;
  _yaw_type yaw;

   typedef float _vel_type;
  _vel_type vel;

   typedef uint32_t _nsat_type;
  _nsat_type nsat;

   typedef uint32_t _ins_stat_type;
  _ins_stat_type ins_stat;

   typedef uint32_t _sol_type;
  _sol_type sol;

   typedef uint32_t _pos_type;
  _pos_type pos;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _ins_str_type;
  _ins_str_type ins_str;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _sol_str_type;
  _sol_str_type sol_str;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _pos_str_type;
  _pos_str_type pos_str;




  typedef boost::shared_ptr< ::span_pose::span_pose_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::span_pose::span_pose_<ContainerAllocator> const> ConstPtr;

}; // struct span_pose_

typedef ::span_pose::span_pose_<std::allocator<void> > span_pose;

typedef boost::shared_ptr< ::span_pose::span_pose > span_posePtr;
typedef boost::shared_ptr< ::span_pose::span_pose const> span_poseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::span_pose::span_pose_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::span_pose::span_pose_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace span_pose

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'span_pose': ['/home/shiyu/recboat/recboat-ros/src/span_pose/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::span_pose::span_pose_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::span_pose::span_pose_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::span_pose::span_pose_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::span_pose::span_pose_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::span_pose::span_pose_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::span_pose::span_pose_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::span_pose::span_pose_<ContainerAllocator> >
{
  static const char* value()
  {
    return "23ce8b6d28cd252c454bfbb763592305";
  }

  static const char* value(const ::span_pose::span_pose_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x23ce8b6d28cd252cULL;
  static const uint64_t static_value2 = 0x454bfbb763592305ULL;
};

template<class ContainerAllocator>
struct DataType< ::span_pose::span_pose_<ContainerAllocator> >
{
  static const char* value()
  {
    return "span_pose/span_pose";
  }

  static const char* value(const ::span_pose::span_pose_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::span_pose::span_pose_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
uint32 ver\n\
uint32 sec\n\
uint32 usec\n\
\n\
float64 lat\n\
float64 lon\n\
\n\
float64 north\n\
float64 east\n\
float64 z\n\
\n\
float32 roll\n\
float32 pitch\n\
float32 yaw\n\
\n\
float32 vel\n\
\n\
uint32 nsat\n\
uint32 ins_stat\n\
uint32 sol\n\
uint32 pos\n\
string ins_str\n\
string sol_str\n\
string pos_str\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::span_pose::span_pose_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::span_pose::span_pose_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.ver);
      stream.next(m.sec);
      stream.next(m.usec);
      stream.next(m.lat);
      stream.next(m.lon);
      stream.next(m.north);
      stream.next(m.east);
      stream.next(m.z);
      stream.next(m.roll);
      stream.next(m.pitch);
      stream.next(m.yaw);
      stream.next(m.vel);
      stream.next(m.nsat);
      stream.next(m.ins_stat);
      stream.next(m.sol);
      stream.next(m.pos);
      stream.next(m.ins_str);
      stream.next(m.sol_str);
      stream.next(m.pos_str);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct span_pose_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::span_pose::span_pose_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::span_pose::span_pose_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "ver: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ver);
    s << indent << "sec: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sec);
    s << indent << "usec: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.usec);
    s << indent << "lat: ";
    Printer<double>::stream(s, indent + "  ", v.lat);
    s << indent << "lon: ";
    Printer<double>::stream(s, indent + "  ", v.lon);
    s << indent << "north: ";
    Printer<double>::stream(s, indent + "  ", v.north);
    s << indent << "east: ";
    Printer<double>::stream(s, indent + "  ", v.east);
    s << indent << "z: ";
    Printer<double>::stream(s, indent + "  ", v.z);
    s << indent << "roll: ";
    Printer<float>::stream(s, indent + "  ", v.roll);
    s << indent << "pitch: ";
    Printer<float>::stream(s, indent + "  ", v.pitch);
    s << indent << "yaw: ";
    Printer<float>::stream(s, indent + "  ", v.yaw);
    s << indent << "vel: ";
    Printer<float>::stream(s, indent + "  ", v.vel);
    s << indent << "nsat: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.nsat);
    s << indent << "ins_stat: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ins_stat);
    s << indent << "sol: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sol);
    s << indent << "pos: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.pos);
    s << indent << "ins_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.ins_str);
    s << indent << "sol_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.sol_str);
    s << indent << "pos_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.pos_str);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SPAN_POSE_MESSAGE_SPAN_POSE_H
